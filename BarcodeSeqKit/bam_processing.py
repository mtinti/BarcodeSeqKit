"""Processing BAM files for barcode extraction and classification"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_bam_processing.ipynb.

# %% auto 0
__all__ = ['BamUtils', 'extract_softclipped_region', 'BamExtractor']

# %% ../nbs/02_bam_processing.ipynb 4
import os
import re
import gzip
import logging
import shutil
from typing import List, Dict, Tuple, Set, Optional, Union, Iterator, Any, Counter
from pathlib import Path
import pysam
import tempfile
import pysam
import numpy as np
from pysam import AlignmentFile, AlignedSegment
import subprocess
from tqdm.auto import tqdm
from BarcodeSeqKit.core import (
    BarcodeConfig, 
    BarcodeMatch, 
    OrientationType,
    BarcodeExtractor, 
    ExtractionStatistics,
    BarcodeLocationType
)
#from BarcodeSeqKit.sequence_utils import classify_alignment_by_first_match
from .sequence_utils import classify_read_by_first_match

# %% ../nbs/02_bam_processing.ipynb 6
class BamUtils:
    """Utility functions for BAM file operations."""
    
    @staticmethod
    def sort_and_index(bam_file: str) -> None:
        """Sort and index a BAM file by reference.
        
        Args:
            bam_file: Path to the BAM file
        """
        # Create a temporary file for sorting
        temp_file = f"{bam_file}.temp.bam"
        
        # Sort the BAM file to a temporary file
        pysam.sort("-o", temp_file, bam_file)
        
        # Replace the original with the sorted file
        os.replace(temp_file, bam_file)
        
        # Index the BAM file
        pysam.index(bam_file)
    
    @staticmethod
    def get_read_count(bam_file: str) -> int:
        """Get the total number of reads in a BAM file.
        
        Args:
            bam_file: Path to the BAM file
            
        Returns:
            Total number of reads
        """
        # Run samtools idxstats to get read counts
        cmd = ["samtools", "idxstats", bam_file]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise RuntimeError(f"Error running samtools idxstats: {result.stderr}")
        
        # Parse the output
        mapped = 0
        unmapped = 0
        for line in result.stdout.strip().split("\n"):
            if not line:
                continue
            parts = line.split("\t")
            if len(parts) >= 4:
                mapped += int(parts[2])
                unmapped += int(parts[3])
        
        return mapped + unmapped
    
    @staticmethod
    def merge_bam_files(output_file: str, input_files: List[str]) -> None:
        """Merge multiple BAM files into one.
        
        Args:
            output_file: Path to the output BAM file
            input_files: List of input BAM file paths
        """
        if not input_files:
            return
        
        # Use pysam to merge the files
        pysam.merge("-f", output_file, *input_files)

# %% ../nbs/02_bam_processing.ipynb 8
def extract_softclipped_region(read):
    """
    Extracts softclipped regions from an alignment.
    For + strand: gets softclipped region at 5' end of read
    For - strand: gets softclipped region at 3' end of read
    
    Args:
        read: A pysam.AlignedSegment object
    
    Returns:
        str: Softclipped sequence or empty string if none exists
    """
    # Check if the read is unmapped
    if read.is_unmapped:
        return ""
    
    # Get the CIGAR operations
    cigar = read.cigartuples
    if not cigar:
        return ""
    
    # Determine if read is on reverse strand
    is_reverse = read.is_reverse
    
    # For + strand (forward): get softclip at 5' end (first operation)
    # For - strand (reverse): get softclip at 3' end (last operation)
    if is_reverse:
        # We want the last operation for reverse strand
        last_op = cigar[-1]
        if last_op[0] == 4:  # 4 is the CIGAR code for softclip
            # Get softclipped region at 3' end (last part of sequence)
            soft_clip_length = last_op[1]
            return read.query_sequence[-soft_clip_length:]
    else:
        # We want the first operation for forward strand
        first_op = cigar[0]
        if first_op[0] == 4:  # 4 is the CIGAR code for softclip
            # Get softclipped region at 5' end (first part of sequence)
            soft_clip_length = first_op[1]
            return read.query_sequence[:soft_clip_length]
    
    # No softclipped region found based on criteria
    return ""

# %% ../nbs/02_bam_processing.ipynb 9
class BamExtractor(BarcodeExtractor):
    """Extracts barcodes from BAM files."""
    
    def __init__(
        self, 
        barcodes: List[BarcodeConfig],
        output_prefix: str,
        bam_file: str,
        output_dir: Optional[str] = None,
        merge_orientations: bool = False,
        keep_unmatched: bool = True,
        verbose: bool = False,
        log_file: Optional[str] = None,
        max_mismatches: int = 0,
        search_softclipped: bool = False
        
    ):
        """Initialize the BAM extractor.
        
        Args:
            barcodes: List of barcode configurations
            output_prefix: Prefix for output files
            bam_file: Path to the input BAM file
            output_dir: Directory for output files
            merge_orientations: Whether to merge forward and reverse complement orientations
            keep_unmatched: Whether to keep reads without barcodes
            verbose: Whether to enable verbose logging
            log_file: Path to log file
            max_mismatches: Maximum number of mismatches allowed in barcode detection
            search_softclipped: Whether to search for barcodes in a softclipped read region, at 5' on plus strand, at 3 on minus strand' 
        """
        super().__init__(
            barcodes=barcodes,
            output_prefix=output_prefix,
            output_dir=output_dir,
            merge_orientations=merge_orientations,
            keep_unmatched=keep_unmatched,
            verbose=verbose,
            log_file=log_file
        )
        
        # Validate BAM file
        if not os.path.exists(bam_file):
            raise FileNotFoundError(f"BAM file not found: {bam_file}")
        
        self.bam_file = bam_file
        self.max_mismatches = max_mismatches
        self.search_softclipped = search_softclipped
        self.single_barcode_mode = len(self.barcodes) == 1 or all(b.location.value == "UNK" for b in self.barcodes)
        
        # Check if BAM file is sorted and indexed
        try:
            # Try to open the index file
            pysam.AlignmentFile(bam_file, "rb").check_index()
            self.is_indexed = True
        except (ValueError, IOError):
            self.logger.warning(f"BAM file is not indexed: {bam_file}")
            self.logger.info("Sorting and indexing BAM file...")
            BamUtils.sort_and_index(bam_file)
            self.is_indexed = True
        
        # Prepare output categories based on barcodes
        self.categories = self._prepare_categories()
        
        # Count the total number of reads
        self.total_reads = BamUtils.get_read_count(bam_file)
        
        #self.logger.info(f"Initialized BamExtractor with {len(barcodes)} barcodes")
        #self.logger.info(f"BAM file: {bam_file} ({self.total_reads} reads)")
        #self.logger.info(f"Output categories: {self.categories}")
    
    def _prepare_categories(self) -> List[str]:
        """Prepare output categories based on barcodes.
        
        Returns:
            List of category names
        """
        categories = []
        
        if self.single_barcode_mode:
            # Single barcode mode (either one barcode or multiple without specific locations)
            categories.extend(["barcode_orientFR", "barcode_orientRC"])
        else:
            # Multiple barcodes with specific locations (5' and/or 3')
            for barcode in self.barcodes:
                if barcode.location.value in ["5", "3"]:
                    categories.extend([
                        f"barcode{barcode.location.value}_orientFR",
                        f"barcode{barcode.location.value}_orientRC"
                    ])
        
        # Add no barcode category
        if self.keep_unmatched:
            categories.append("noBarcode")
        
        return categories
    
    def extract(self) -> ExtractionStatistics:
        """Extract barcodes from the BAM file.
        
        Returns:
            Statistics from the extraction process
        """
        #self.logger.info("Starting barcode extraction from BAM file")
        
        # Initialize statistics
        stats = ExtractionStatistics()
        stats.total_reads = self.total_reads
        
        # Open the input BAM file
        bamfile = pysam.AlignmentFile(self.bam_file, "rb")
        
        # Initialize output BAM files
        output_files = self._init_output_files(bamfile)
        
        # Track processed reads to avoid duplicates
        read_classifications = {}
        
        # Process each read in the BAM file
        read_count = 0
        
        try:
            # First pass: classify reads by barcode
            for read in bamfile:
                #print('extract_softclipped_region(read)', extract_softclipped_region(read))
                read_count += 1
                
                # Skip if we've already processed this read
                if read.query_name in read_classifications:
                    continue
                
                # Get the read sequence
                if self.search_softclipped:
                    sequence = extract_softclipped_region(read)#
                else:   
                    sequence = read.query_sequence 
                
                
                
                if not sequence:
                    continue
                
                # Search for barcodes
                match, category = self._classify_read(sequence)
                
                # Update statistics and classification
                if match:
                    stats.update_barcode_match(match, category)
                    read_classifications[read.query_name] = category
                else:
                    stats.no_barcode_count += 1
            
            #self.logger.info(f"First pass complete: classified {len(read_classifications)} reads")
            
            # Reset for second pass
            bamfile.close()
            bamfile = pysam.AlignmentFile(self.bam_file, "rb")
            read_count = 0
            
            # Second pass: write reads to output files
            for read in bamfile:
                read_count += 1
                
                category = read_classifications.get(read.query_name, "noBarcode")
                
                # Write to output file
                if category in output_files:
                    output_files[category].write(read)
                
        finally:
            # Close all file handles
            bamfile.close()
            for category, f in output_files.items():
                self.logger.debug(f"Closing output file for category {category}")
                f.close()
        
        self.logger.info(f"Extraction complete: {stats.total_barcode_matches} matches in {stats.total_reads} reads")
        
        # Log detailed statistics
        #self.logger.info("Match statistics by category:")
        #for category, count in stats.matches_by_category.items():
        #    self.logger.info(f"  {category}: {count} matches")
        
        # Sort and index all output files
        for category in output_files:
            file_path = self._get_output_path(category)
            #self.logger.info(f"Sorting and indexing {file_path}")
            BamUtils.sort_and_index(file_path)
        
        # Save statistics
        self.statistics = stats  # Store the statistics for reference
        self.save_statistics()
        
        return stats
    
    def _classify_read(self, sequence: str) -> Tuple[Optional[BarcodeMatch], str]:
        """Classify a read sequence based on barcode matches.
        
        Args:
            sequence: Read sequence to classify
            
        Returns:
            Tuple of (best_match, category)
        """
        sequence = sequence.upper()
        match, original_category = classify_read_by_first_match(
            sequence=sequence,
            barcodes=self.barcodes,
            max_mismatches=self.max_mismatches
        )
        
        # Adjust category based on single barcode mode or specific location mode
        if match:
            if self.single_barcode_mode:
                # For single barcode mode, use simpler categories
                if match.orientation == OrientationType.FORWARD:
                    return match, "barcode_orientFR"
                else:  # REVERSE_COMPLEMENT
                    return match, "barcode_orientRC"
            else:
                # For multiple barcodes with locations, use the location in the category
                location = match.barcode.location.value
                if location in ["5", "3"]:
                    orientation = match.orientation.value
                    return match, f"barcode{location}_orient{orientation}"
        
        return match, "noBarcode"
    
    def _init_output_files(self, template_file: pysam.AlignmentFile) -> Dict[str, pysam.AlignmentFile]:
        """Initialize output BAM files.
        
        Args:
            template_file: Template BAM file
            
        Returns:
            Dictionary mapping categories to output file handles
        """
        output_files = {}
        
        for category in self.categories:
            output_path = self._get_output_path(category)
            self.logger.debug(f"Creating output file for category {category}: {output_path}")
            output_files[category] = pysam.AlignmentFile(
                output_path, "wb", template=template_file
            )
        
        return output_files
    
    def _get_output_path(self, category: str) -> str:
        """Get the output path for a category.
        
        Args:
            category: Category name
            
        Returns:
            Path to the output BAM file
        """
        filename = f"{self.output_prefix}_{category}.bam"
        return os.path.join(self.output_dir, filename)
    
    def _find_barcode_matches(self, sequence: str) -> List[BarcodeMatch]:
        """Find barcode matches in a sequence.
        
        Args:
            sequence: The sequence to search in
            
        Returns:
            List of BarcodeMatch objects
        """
        match, _ = self._classify_read(sequence)
        
        if match:
            return [match]
        else:
            return []
